C*MODULE RSM_MOD  *DECK RISM_IO
C>
C>    @brief   module for RISM I/O
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RISM_IO
      IMPLICIT NONE

      INTEGER, PARAMETER :: IRSDAF=26, IRSSQF=27
      INTEGER, PARAMETER :: MAXIO = 1000, IRECLN = 4090
C
C     RISM INPUT, OUTPUT, and PUNCH FILES (GLOBAL)
C
      INTEGER            :: IR, IW, IP
C
C     RISM DICTIONARY FILE (GLOBAL)
C
      INTEGER            :: IRECST,IFILEN(MAXIO),IODARS(MAXIO)
C
      CONTAINS

C*MODULE RSM_MOD  *DECK RSM_SETIO
C>
C>    @brief   read i/o data from dictionary file
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SETIO

          INTEGER :: I0
C
C         IR, IW, IP
C
          CALL RSM_DARE(I0,1,501,0)

          IP = MOD(I0,100)
          I0 = I0/100
          IW = MOD(I0,100)
          IR = I0/100

        END SUBROUTINE
C*MODULE RSM_MOD  *DECK RSM_PUTIO
C>
C>    @brief   save i/o data from dictionary file
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_PUTIO

          INTEGER :: IRIWIP
C
C         IR, IW, IP
C
          IRIWIP = 10000*IR + 100*IW  + IP
          CALL RSM_DAWR(IRIWIP,1,501,0)
        END SUBROUTINE

      END MODULE

C*MODULE RISM_MOD
C>
C>    @brief   module for RISM calculation
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RISM_MOD
      IMPLICIT NONE
C
C     INFORMATION ABOUT SOLUTE and SOLVENT
C
C     NTAB = NGRID (0 to NGRID-1)
C          = NRAD
C
      INTEGER, SAVE        :: NU, NV, NTAB, NSHEL0A       ! G1
C
C     PARAMETER FOR FFT
C
      INTEGER, SAVE        :: IGRD_TYP                    ! G1
C
C     PARAMETERS OF SOLVENT
C
      DOUBLE PRECISION     :: BETA                        ! G2
C
C     PARAMETERS FOR RISM
C
      INTEGER              :: NRISM
      DOUBLE PRECISION     :: ALPA, CLTYP                 ! G1
      INTEGER              :: IRSM_DAMP
C
C     PARAMETER FOR RISM-SCF
C 
      INTEGER              :: IREST                       ! G1
C
C     FREE ENERGYIES
C
      DOUBLE PRECISION     :: FHNC, FGF, FKH, FPSE2, FPSE3, EUU, FRISM  ! 
      DOUBLE PRECISION     :: EUV_E2, EUV_E8, E0, ESTATE(10)
      DOUBLE PRECISION     :: EBOX(22)
C
C     PARAMETER FOR PARALLEL CALCULATION (GLOBAL)
C
      LOGICAL, SAVE        :: GOPARR, MASWRK, DSKWRK      
      INTEGER              :: NPROC, ME, MASTER           
C
C     RISM PART
C
      INTEGER              :: JDIIS, NEXP, MXDIIS, LJRULE ! G1
      INTEGER, ALLOCATABLE :: INDU(:), INDV(:), IJUV(:,:)
      DOUBLE PRECISION     :: DELEX, XMN, THR, RMAX       ! G1

      DOUBLE PRECISION, ALLOCATABLE :: QU(:),QV(:)
      DOUBLE PRECISION, ALLOCATABLE :: ET0(:,:),FQS(:,:),FQLK(:,:),
     *                                 CSB(:,:),FNEP(:,:),WU(:,:,:),
     *                                 HWV(:,:,:),DENV(:),DHK(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: RTAB(:), RKTAB(:)
C
C     LOOKUP TABLE
C
      INTEGER              :: IDISP,  IREP
      INTEGER              :: NP_DIS, NP_REP
      DOUBLE PRECISION              :: EU_DIS, EU_REP
      DOUBLE PRECISION, ALLOCATABLE :: TAB_DIS(:,:,:), TAB_REP(:,:,:),
     *                                  DELSI_DIS(:,:), DELSI_REP(:,:)
C
C     BRIDGE 
C
      DOUBLE PRECISION, SAVE        :: FREF, FPT, FCH0             ! G2
      DOUBLE PRECISION, ALLOCATABLE :: HREF(:,:),BRG(:,:),FRLJ(:),
     *                                  HKREF(:,:)
C
C     INTEGRATION
C
      DOUBLE PRECISION              :: RMX_SYMP, RKMX_SYMP         ! G2
C
C     MCQDPT
C
      INTEGER              :: IROOT
C
C     TDDFT
C
      DOUBLE PRECISION              :: EDIFMX
C
      CONTAINS
C*MODULE RISM_MOD  *DECK RSM_ISTIEND
C>
C>    @brief   give starting and ending points for parallel calculation
C>
C>    @author  Daisuke Yokogawa
C>
C>    @param   NUM: the number of loop to be parallelized
C>             ISTRT: starting point
C>             IEND: ending point
C>             NDIM: the size of loop 
C>
        SUBROUTINE RSM_ISTIEND(NUM,ISTRT,IEND,NDIM)

        INTEGER, INTENT(IN   ) :: NUM
        INTEGER, INTENT(  OUT) :: ISTRT, IEND, NDIM
      
        INTEGER NMOD, NDIV

        NMOD=MOD(NUM,NPROC)
        NDIV=FLOOR(REAL(NUM/NPROC,8))

        IF(ME.LT.NMOD) THEN
           ISTRT=ME*(NDIV+1)+1
           IEND =ISTRT+NDIV
           NDIM =NDIV+1
        ELSEIF(ME.EQ.NMOD) THEN
           ISTRT=ME*(NDIV+1)+1
           IEND =ISTRT+NDIV-1
           NDIM =NDIV
        ELSE
           ISTRT=ME*NDIV+NMOD+1
           IEND =ISTRT+NDIV-1
           NDIM =NDIV
        ENDIF

        RETURN
        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_PUTPAR
C>
C>    @brief   save parameters for RISM calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_PUTPAR

        INTEGER  :: I0, I1

        I0 = 100*NU    + NV
        I1 = 10000*LJRULE + 1000*IRSM_DAMP + 100*IREST + JDIIS

        CALL RSM_DAWR(I0       ,    1,551,0)
        CALL RSM_DAWR(NTAB     ,    1,552,0)
        CALL RSM_DAWR(NSHEL0A  ,    1,553,0)
        CALL RSM_DAWR(IGRD_TYP ,    1,554,0)
        CALL RSM_DAWR(ALPA     ,    1,555,0)
        CALL RSM_DAWR(CLTYP    ,    1,556,0)
        CALL RSM_DAWR(I1       ,    1,557,0)       
        CALL RSM_DAWR(NEXP     ,    1,558,0)
        CALL RSM_DAWR(MXDIIS   ,    1,559,0)
        CALL RSM_DAWR(DELEX    ,    1,560,0)
        CALL RSM_DAWR(XMN      ,    1,561,0)
        CALL RSM_DAWR(THR      ,    1,562,0)
        CALL RSM_DAWR(BETA     ,    1,563,0)
        CALL RSM_DAWR(FREF     ,    1,564,0)
        CALL RSM_DAWR(FPT      ,    1,565,0)
        CALL RSM_DAWR(FCH0     ,    1,566,0)
        CALL RSM_DAWR(RMX_SYMP ,    1,567,0)
        CALL RSM_DAWR(RKMX_SYMP,    1,568,0)
        CALL RSM_DAWR(IROOT    ,    1,570,0)
        CALL RSM_DAWR(EDIFMX   ,    1,571,0)
        CALL RSM_DAWR(RMAX     ,    1,573,0)

        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_PUTPAR
C>
C>    @brief   read parameters for RISM calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SETPAR

        INTEGER  :: I0, I1

        CALL RSM_DARE(I0       ,    1,551,0)
        CALL RSM_DARE(NTAB     ,    1,552,0)
        CALL RSM_DARE(NSHEL0A  ,    1,553,0)
        CALL RSM_DARE(IGRD_TYP ,    1,554,0)
        CALL RSM_DARE(ALPA     ,    1,555,0)
        CALL RSM_DARE(CLTYP    ,    1,556,0)
        CALL RSM_DARE(I1       ,    1,557,0)
        CALL RSM_DARE(NEXP     ,    1,558,0)
        CALL RSM_DARE(MXDIIS   ,    1,559,0)
        CALL RSM_DARE(DELEX    ,    1,560,0)
        CALL RSM_DARE(XMN      ,    1,561,0)
        CALL RSM_DARE(THR      ,    1,562,0)
        CALL RSM_DARE(BETA     ,    1,563,0)
        CALL RSM_DARE(FREF     ,    1,564,0)
        CALL RSM_DARE(FPT      ,    1,565,0)
        CALL RSM_DARE(FCH0     ,    1,566,0)
        CALL RSM_DARE(RMX_SYMP ,    1,567,0)
        CALL RSM_DARE(RKMX_SYMP,    1,568,0)
        CALL RSM_DARE(IROOT    ,    1,570,0)
        CALL RSM_DARE(EDIFMX   ,    1,571,0)
        CALL RSM_DARE(RMAX     ,    1,573,0)

        NV = MOD(I0,100)
        NU = I0/100

        LJRULE    = I1/10000
        I1        = I1 - 10000*LJRULE
        IRSM_DAMP = I1/1000
        I1        = I1 - 1000*IRSM_DAMP
        IREST     = I1/100
        JDIIS     = I1 - 100 *IREST

        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_PUTPAR
C>
C>    @brief   read matrix data for RISM calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SETVAR

        INTEGER :: L01, L02, L03, L05, L11, L12, L13, L14, L21, L22, L23

        L01 = NU
        L02 = NV
        L03 = NTAB
        L05 = NTAB
        L11 = NU*NU
        L12 = NV*NV
        L13 = NU*NV
        L14 = (NSHEL0A+1)*(NSHEL0A+1)
        L21 = NTAB*NV*NV
        L22 = NTAB*NU*NV
        L23 = NTAB*NU*NU

        ALLOCATE(ET0(NTAB,L13),
     *           FQS(NTAB,L13),FQLK(NTAB,L13),CSB(NTAB,L13),
     *           FNEP(NTAB,L13),WU(NTAB,NU,NU),QU(L01),
     *           QV(L02),HWV(NTAB,NV,NV),DENV(L02),DHK(NTAB,L13),
     *           RTAB(L03),RKTAB(L03),
     *           HREF(NTAB,L13),BRG(NTAB,L13),FRLJ(NU),HKREF(NTAB,L13))
        ALLOCATE(INDV(L13),IJUV(NU,NV),INDU(L13))
C
C       PEAD STORED DATA
C
        CALL RSM_DARE(DENV,L02, 4,0)
        CALL RSM_DARE(HWV ,L21,11,0)
        CALL RSM_DARE(ET0 ,L22,16,0)
        CALL RSM_DARE(CSB ,L22,17,0)
        CALL RSM_DARE(FQLK,L22,18,0)
        CALL RSM_DARE(INDU,L13,26,0)
        CALL RSM_DARE(INDV,L13,27,0)
        CALL RSM_DARE(IJUV,L13,28,0)

        CALL RSM_DARE(QV   ,L02,  3,0)
        CALL RSM_DARE(RTAB ,L05,  8,0)
        CALL RSM_DARE(RKTAB,L05,  9,0)
        CALL RSM_DARE(FNEP ,L22, 12,0)
        CALL RSM_DARE(BRG  ,L22, 20,0)
        CALL RSM_DARE(HREF ,L22, 21,0)
        CALL RSM_DARE(WU   ,L23, 47,0)
!       CALL RSM_DARE(FQS  ,L22, 97,0)

        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_PUTPAR
C>
C>    @brief   save matrix data for RISM calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_PUTVAR

        INTEGER :: L22

        L22 = NTAB*NU*NV
C
C       STORE DATA
C
        CALL RSM_DAWR(ET0 ,L22,16,0)
        CALL RSM_DAWR(CSB ,L22,17,0)
        CALL RSM_DAWR(FQLK,L22,18,0)
C       CALL RSM_DAWR(FQS ,L22,19,0)
C
        DEALLOCATE(ET0,FQS,FQLK,CSB,FNEP,WU,QU,QV,HWV,DENV,DHK,RTAB,
     *             RKTAB,HREF,BRG,FRLJ,HKREF,INDV,IJUV,INDU)

        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_PUTENE
C>
C>    @brief   save solvation free energies
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_PUTENE

        INTEGER :: I

        EBOX( 1) = FHNC
        EBOX( 2) = FGF
        EBOX( 3) = FKH
        EBOX( 4) = EUU
        EBOX( 5) = FRISM
        EBOX( 6) = EUV_E2
        EBOX( 7) = EUV_E8
        EBOX( 8) = E0
        EBOX( 9) = FPSE2
        EBOX(10) = FPSE3

        DO I=1, 10
          EBOX(I+10) = ESTATE(I)
        ENDDO

        CALL RSM_DAWR(EBOX ,20,569,0)

        END SUBROUTINE
C*MODULE RISM_MOD  *DECK RSM_SETENE
C>
C>    @brief   read solvation free energies
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SETENE

        INTEGER :: I

        CALL RSM_DARE(EBOX ,20,569,0)

        FHNC   = EBOX( 1)
        FGF    = EBOX( 2)
        FKH    = EBOX( 3)
        EUU    = EBOX( 4)
        FRISM  = EBOX( 5)
        EUV_E2 = EBOX( 6)
        EUV_E8 = EBOX( 7)
        E0     = EBOX( 8)
        FPSE2  = EBOX( 9)
        FPSE3  = EBOX(10)

        DO I=1, 10
          ESTATE(I) = EBOX(I+10)
        ENDDO

        END SUBROUTINE
C
      END MODULE
C*MODULE RISMUN_MOD
C>
C>    @brief   module for grid information of uniform-grid RISM
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RISMUN_MOD
      IMPLICIT NONE
C
C     GRID DATA
C
      DOUBLE PRECISION, SAVE        :: DELTR, DELTK

      END MODULE
C*MODULE RISMLN_MOD
C>
C>    @brief   module for grid information of log-grid RISM
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RISMLN_MOD
      IMPLICIT NONE
C
C
C
      INTEGER             :: NRAD,MRAD,MXPNT
      DOUBLE PRECISION    :: DRHO,RHOM
C
      DOUBLE PRECISION, ALLOCATABLE :: R32(:)

      END MODULE
C*MODULE ABSMOD
C>
C>    @brief   module for auxiliary basis set
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE ABSMOD
      IMPLICIT NONE
C
      INTEGER              :: NRAD, NMUESP, NMUREP, IFITU              ! G1
      DOUBLE PRECISION     :: XMNFIT, XMUMX                            ! G1
C
      INTEGER, SAVE        :: MXG, MXS, NSHEL0A, NQMT0A, JABS,         ! G1
     *                        MXANG_ABS

      INTEGER, ALLOCATABLE :: KSTRT0A(:),KATM0A(:),KTYP0A(:),KNG0A(:), ! G1
     *                        KLOC0A(:),KMIN0A(:),KMAX0A(:)
      DOUBLE PRECISION, ALLOCATABLE :: EX0A(:),COF0A(:)                         ! G1

      INTEGER, ALLOCATABLE :: KATM_QMT0A(:)                            ! G1
      DOUBLE PRECISION, SAVE        :: QMTTOL                                   ! G1
      DOUBLE PRECISION, ALLOCATABLE :: TQ(:,:),FMAT(:,:)                        ! G1
C
      DOUBLE PRECISION              :: TRN1(9,10),TRN2(10,9),TRN3(10,10)        ! G1
C
      CONTAINS
C*MODULE ABSMOD  *DECK RSM_SETABS
C>
C>    @brief   read information about ABS
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SETABS

        INTEGER :: I0

        CALL RSM_DARE(NRAD   ,     1         ,596,0)
        CALL RSM_DARE(I0     ,     1         ,597,0)
        CALL RSM_DARE(IFITU  ,     1         ,598,0)
        CALL RSM_DARE(XMNFIT ,     1         ,599,0)
        CALL RSM_DARE(XMUMX  ,     1         ,600,0)
        CALL RSM_DARE(MXG    ,     1         ,576,0)
        CALL RSM_DARE(MXS    ,     1         ,577,0)
        CALL RSM_DARE(NSHEL0A,     1         ,578,0)
        CALL RSM_DARE(NQMT0A ,     1         ,579,0)
        CALL RSM_DARE(JABS   ,     1         ,580,0)
        CALL RSM_DARE(QMTTOL ,     1         ,581,0)

        NMUREP = MOD(I0,100)
        NMUESP = I0/100

        ALLOCATE(KSTRT0A(MXS),KATM0A(MXS),KTYP0A(MXS),KNG0A(MXS),
     *           KLOC0A(MXS),KMIN0A(MXS),KMAX0A(MXS))
        ALLOCATE(EX0A(MXG),COF0A(MXG))
        ALLOCATE(KATM_QMT0A(MXS))
        ALLOCATE(TQ(NSHEL0A,NSHEL0A),FMAT(NQMT0A,NRAD))

        CALL RSM_DARE(KSTRT0A   ,MXS            ,582,0)
        CALL RSM_DARE(KATM0A    ,MXS            ,583,0)
        CALL RSM_DARE(KTYP0A    ,MXS            ,584,0)
        CALL RSM_DARE(KNG0A     ,MXS            ,585,0)
        CALL RSM_DARE(KLOC0A    ,MXS            ,586,0)
        CALL RSM_DARE(KMIN0A    ,MXS            ,587,0)
        CALL RSM_DARE(KMAX0A    ,MXS            ,588,0)
        CALL RSM_DARE(EX0A      ,MXG            ,589,0)
        CALL RSM_DARE(COF0A     ,MXG            ,590,0)
        CALL RSM_DARE(KATM_QMT0A,MXS            ,591,0)
        CALL RSM_DARE(TQ        ,NSHEL0A*NSHEL0A,592,0)
        CALL RSM_DARE(TRN1      ,90             ,593,0)
        CALL RSM_DARE(TRN2      ,90             ,594,0)
        CALL RSM_DARE(TRN3      ,100            ,595,0)
        CALL RSM_DARE(FMAT      ,NQMT0A*NRAD    ,601,0)
        CALL RSM_DARE(MXANG_ABS ,1              ,602,0)

        END SUBROUTINE
C*MODULE ABSMOD  *DECK RSM_PUTABS
C>
C>    @brief   save information about ABS
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_PUTABS(I1,I2,I3,I4,I5,I6,I7,I8,V1,V2,V3,V4,V5,V6,
     *                        V7)

        INTEGER,          INTENT(IN   ) :: I1(*),I2(*),I3(*),I4(*),
     *                                     I5(*),I6(*),I7(*),I8(*)
        DOUBLE PRECISION, INTENT(IN   ) :: V1(*),V2(*),V3(*),V4(*),
     *                                     V5(*),V6(*),V7(*)

        INTEGER :: I0

        I0 = 100*NMUESP + NMUREP

        CALL RSM_DAWR(NRAD   ,     1         ,596,0)
        CALL RSM_DAWR(I0     ,     1         ,597,0)
        CALL RSM_DAWR(IFITU  ,     1         ,598,0)
        CALL RSM_DAWR(XMNFIT ,     1         ,599,0)
        CALL RSM_DAWR(XMUMX  ,     1         ,600,0)
        CALL RSM_DAWR(MXG    ,     1         ,576,0)
        CALL RSM_DAWR(MXS    ,     1         ,577,0)
        CALL RSM_DAWR(NSHEL0A,     1         ,578,0)
        CALL RSM_DAWR(NQMT0A ,     1         ,579,0)
        CALL RSM_DAWR(JABS   ,     1         ,580,0)
        CALL RSM_DAWR(QMTTOL ,     1         ,581,0)
        CALL RSM_DAWR(I1     ,MXS            ,582,0)
        CALL RSM_DAWR(I2     ,MXS            ,583,0)
        CALL RSM_DAWR(I3     ,MXS            ,584,0)
        CALL RSM_DAWR(I4     ,MXS            ,585,0)
        CALL RSM_DAWR(I5     ,MXS            ,586,0)
        CALL RSM_DAWR(I6     ,MXS            ,587,0)
        CALL RSM_DAWR(I7     ,MXS            ,588,0)
        CALL RSM_DAWR(V1     ,MXG            ,589,0)
        CALL RSM_DAWR(V2     ,MXG            ,590,0)
        CALL RSM_DAWR(I8     ,MXS            ,591,0)
        CALL RSM_DAWR(V3     ,NSHEL0A*NSHEL0A,592,0)
        CALL RSM_DAWR(V4     ,90             ,593,0)
        CALL RSM_DAWR(V5     ,90             ,594,0)
        CALL RSM_DAWR(V6     ,100            ,595,0)
        CALL RSM_DAWR(V7     ,NQMT0A*NRAD    ,601,0)
        CALL RSM_DAWR(MXANG_ABS,    1        ,602,0)

        END SUBROUTINE
C*MODULE ABSMOD  *DECK RSM_PUTABS
C>
C>    @brief   deallocate memories of ABS
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_CLOSEABS

        DEALLOCATE(KSTRT0A,KATM0A,KTYP0A,KNG0A,KLOC0A,KMIN0A,KMAX0A,
     *             EX0A,COF0A,KATM_QMT0A,TQ,FMAT)
        END SUBROUTINE
C
      END MODULE
C*MODULE RSMSED
C>
C>    @brief   module for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RSMSED
      IMPLICIT NONE
C
C     RISM-SCF-CALCULATION (GLOBAL)
C
      INTEGER, SAVE          :: ICNTRL(18)
      INTEGER, SAVE          :: IRISM        ! G2
C
C     PRINT OPTION
C
      INTEGER, SAVE          :: NPRINT       ! G2
C
C     QM CALCULATION TYPE  (GLOBAL)
C
C     ----- CC calculation
C
      INTEGER, SAVE          :: ICC          ! G2
C
C     ----- MCSCF calculation
C
      INTEGER, SAVE          :: IMCSCF              ! G2
C
C     ----- DFT calculation 
C
      INTEGER, SAVE          :: IDFT, ITDDFT, IZINC ! G2
      INTEGER, SAVE          :: ITER_RSMTD          ! G2
      DOUBLE PRECISION, SAVE :: TDTYP               ! G2
C
C     ----- CONICAL INTERSECTIOn SERCH
C
      INTEGER, SAVE          :: ICONCL              ! G2
C
C     RISM-SCF CYCLE
C
      DOUBLE PRECISION, SAVE :: RCNTRL(8)
      INTEGER, SAVE          :: NSERCH            ! G2
      INTEGER, SAVE          :: ITRRSM, IEXP      ! G2
      DOUBLE PRECISION, SAVE :: FEXP, ETOT, EINT1, EINT2, EINT3, G1, G3 ! G2
      INTEGER, SAVE          :: ITDCONV
      INTEGER                :: ISKIP_RSM
      INTEGER                :: IRSM_COUNT
C
C     SPECTROSCOPIC CALCULATION
C
      INTEGER, SAVE        :: ISPEC        ! G2
C
C     ----- EQUILIBRIUM/NONEQUILIBRIUM CALCULATION
C
      INTEGER, SAVE        :: IEQ          ! G2
C
C     ----- INITIAL AND FINAL STATES
C
      INTEGER, SAVE        :: NROOT_I, MUL_I
C
C     D correction
C
      INTEGER, SAVE        :: IDCORR       ! G2
C
C     /RSINFA/
C
      INTEGER              :: INFOMAT(9)
      INTEGER              :: NAT, ICH, MUL, NUM, NQMT, NE, NA, NB, 
     *                        NROOT  ! G1
      INTEGER, ALLOCATABLE :: IAN(:),IZCORE(:)                      ! G1
      DOUBLE PRECISION, ALLOCATABLE :: ZAN(:),C(:,:),ANAM(:)        ! G1
C
C     RISM-SCF PART
C
      DOUBLE PRECISION, ALLOCATABLE :: QMT(:),VPR(:),DMT(:),VCR(:)
C
C     ROOTS AND WEIGHTS FOR GAUSS-HERMITE QUADRATURE
C
      DOUBLE PRECISION, PARAMETER :: H(120) = 
     *(/0.00000000000000000000D+00, -0.70710678118654752440D+00, 
     *  0.70710678118654752440D+00, -1.22474487139158904910D+00,  
     *  0.00000000000000000000D+00,  1.22474487139158904910D+00, 
     * -1.65068012388578455588D+00, -0.52464762327529031788D+00,  
     *  0.52464762327529031788D+00,  1.65068012388578455588D+00, 
     * -2.02018287045608563293D+00, -0.95857246461381850711D+00,
     *  0.00000000000000000000D+00,  0.95857246461381850711D+00,  
     *  2.02018287045608563293D+00, -2.35060497367449222283D+00, 
     * -1.33584907401369694971D+00, -0.43607741192761650868D+00,  
     *  0.43607741192761650868D+00,  1.33584907401369694971D+00,  
     *  2.35060497367449222283D+00, -2.65196135683523349245D+00, 
     * -1.67355162876747144503D+00, -0.81628788285896466304D+00,  
     *  0.00000000000000000000D+00,  0.81628788285896466304D+00,  
     *  1.67355162876747144503D+00,  2.65196135683523349245D+00, 
     * -2.93063742025724401922D+00, -1.98165675669584292585D+00, 
     * -1.15719371244678019472D+00, -0.38118699020732211685D+00,  
     *  0.38118699020732211685D+00,  1.15719371244678019472D+00,  
     *  1.98165675669584292585D+00,  2.93063742025724401922D+00, 
     * -3.19099320178152760723D+00, -2.26658058453184311180D+00, 
     * -1.46855328921666793167D+00, -0.72355101875283757332D+00, 
     *  0.00000000000000000000D+00,  0.72355101875283757332D+00,  
     *  1.46855328921666793167D+00,  2.26658058453184311180D+00, 
     *  3.19099320178152760723D+00, -3.43615911883773760333D+00, 
     * -2.53273167423278979641D+00, -1.75668364929988177345D+00,
     * -1.03661082978951365418D+00, -0.34290132722370460879D+00,  
     *  0.34290132722370460879D+00,  1.03661082978951365418D+00, 
     *  1.75668364929988177345D+00,  2.53273167423278979641D+00, 
     *  3.43615911883773760333D+00, -3.66847084655958251846D+00,
     * -2.78329009978165177084D+00, -2.02594801582575533517D+00, 
     * -1.32655708449493285595D+00, -6.56809566882099765025D-01,  
     *  0.00000000000000000000D+00,  6.56809566882099765025D-01, 
     *  1.32655708449493285595D+00,  2.02594801582575533517D+00, 
     *  2.78329009978165177084D+00,  3.66847084655958251846D+00, 
     * -3.88972489786978191927D+00, -3.02063702512088977171D+00, 
     * -2.27950708050105990019D+00, -1.59768263515260479671D+00, 
     * -9.47788391240163743705D-01, -3.14240376254359111277D-01,  
     *  3.14240376254359111277D-01,  9.47788391240163743705D-01, 
     *  1.59768263515260479671D+00,  2.27950708050105990019D+00, 
     *  3.02063702512088977171D+00,  3.88972489786978191927D+00, 
     * -4.10133759617863964118D+00, -3.24660897837240998812D+00, 
     * -2.51973568567823788343D+00, -1.85310765160151214200D+00, 
     * -1.22005503659074842622D+00, -6.05763879171060113081D-01,
     *  0.00000000000000000000D+00,  6.05763879171060113081D-01, 
     *  1.22005503659074842622D+00,  1.85310765160151214200D+00, 
     *  2.51973568567823788343D+00,  3.24660897837240998812D+00, 
     *  4.10133759617863964118D+00, -4.30444857047363181262D+00, 
     * -3.46265693360227055021D+00, -2.74847072498540256862D+00, 
     * -2.09518325850771681573D+00, -1.47668273114114087058D+00, 
     * -8.78713787329399416115D-01, -2.91745510672562078446D-01, 
     *  2.91745510672562078446D-01,  8.78713787329399416115D-01, 
     *  1.47668273114114087058D+00,  2.09518325850771681573D+00, 
     *  2.74847072498540256862D+00,  3.46265693360227055021D+00, 
     *  4.30444857047363181262D+00, -4.49999070730939155366D+00, 
     * -3.66995037340445253473D+00, -2.96716692790560324849D+00, 
     * -2.32573248617385774545D+00, -1.71999257518648893242D+00, 
     * -1.13611558521092066632D+00, -5.65069583255575748526D-01, 
     *  0.00000000000000000000D+00,  5.65069583255575748526D-01, 
     *  1.13611558521092066632D+00,  1.71999257518648893242D+00, 
     *  2.32573248617385774545D+00,  2.96716692790560324849D+00, 
     *  3.66995037340445253473D+00,  4.49999070730939155366D+00 /)
      DOUBLE PRECISION, PARAMETER :: W(120) = 
     *(/1.77245385090551602730D+00,  8.86226925452758013649D-01,  
     *  8.86226925452758013649D-01,  2.95408975150919337883D-01,  
     *  1.18163590060367735153D+00,  2.95408975150919337883D-01, 
     *  8.13128354472451771430D-02,  8.04914090005512836506D-01,  
     *  8.04914090005512836506D-01,  8.13128354472451771430D-02, 
     *  1.99532420590459132077D-02,  3.93619323152241159828D-01,  
     *  9.45308720482941881226D-01,  3.93619323152241159828D-01,  
     *  1.99532420590459132077D-02,  4.53000990550884564086D-03,  
     *  1.57067320322856643916D-01,  7.24629595224392524092D-01,  
     *  7.24629595224392524092D-01,  1.57067320322856643916D-01,  
     *  4.53000990550884564086D-03,  9.71781245099519154149D-04,
     *  5.45155828191270305922D-02,  4.25607252610127800520D-01,
     *  8.10264617556807326765D-01,  4.25607252610127800520D-01,
     *  5.45155828191270305922D-02,  9.71781245099519154149D-04,
     *  1.99604072211367619206D-04,  1.70779830074134754562D-02,
     *  2.07802325814891879543D-01,  6.61147012558241291030D-01,
     *  6.61147012558241291030D-01,  2.07802325814891879543D-01,
     *  1.70779830074134754562D-02,  1.99604072211367619206D-04,
     *  3.96069772632643819046D-05,  4.94362427553694721722D-03,
     *  8.84745273943765732880D-02,  4.32651559002555750200D-01,
     *  7.20235215606050957124D-01,  4.32651559002555750200D-01,
     *  8.84745273943765732880D-02,  4.94362427553694721722D-03,
     *  3.96069772632643819046D-05,  7.64043285523262062916D-06,
     *  1.34364574678123269220D-03,  3.38743944554810631362D-02,
     *  2.40138611082314686417D-01,  6.10862633735325798784D-01,  
     *  6.10862633735325798784D-01,  2.40138611082314686417D-01,
     *  3.38743944554810631362D-02,  1.34364574678123269220D-03, 
     *  7.64043285523262062916D-06,  1.43956039371425822033D-06,
     *  3.46819466323345510643D-04,  1.19113954449115324504D-02,
     *  1.17227875167708503382D-01,  4.29359752356125028446D-01,
     *  6.54759286914591779204D-01,  4.29359752356125028446D-01,
     *  1.17227875167708503382D-01,  1.19113954449115324504D-02, 
     *  3.46819466323345510643D-04,  1.43956039371425822033D-06, 
     *  2.65855168435630160602D-07,  8.57368704358785865457D-05,  
     *  3.90539058462906185999D-03,  5.16079856158839299919D-02,
     *  2.60492310264161129233D-01,  5.70135236262479578347D-01,
     *  5.70135236262479578347D-01,  2.60492310264161129233D-01,
     *  5.16079856158839299919D-02,  3.90539058462906185999D-03,
     *  8.57368704358785865457D-05,  2.65855168435630160602D-07,
     *  4.82573185007313108835D-08,  2.04303604027070731249D-05,
     *  1.20745999271938594731D-03,  2.08627752961699392166D-02,
     *  1.40323320687023437763D-01,  4.21616296898543221747D-01,
     *  6.04393187921161642342D-01,  4.21616296898543221747D-01,
     *  1.40323320687023437763D-01,  2.08627752961699392166D-02,
     *  1.20745999271938594731D-03,  2.04303604027070731249D-05,
     *  4.82573185007313108835D-08,  8.62859116812515794532D-09,
     *  4.71648435501891674888D-06,  3.55092613551923610484D-04,
     *  7.85005472645794431049D-03,  6.85055342234652055387D-02,
     *  2.73105609064246603353D-01,  5.36405909712090149795D-01,
     *  5.36405909712090149795D-01,  2.73105609064246603353D-01,
     *  6.85055342234652055387D-02,  7.85005472645794431049D-03,
     *  3.55092613551923610484D-04,  4.71648435501891674888D-06,
     *  8.62859116812515794532D-09,  1.52247580425351702016D-09,
     *  1.05911554771106663578D-06,  1.00004441232499868127D-04,
     *  2.77806884291277589608D-03,  3.07800338725460822287D-02,
     *  1.58488915795935746884D-01,  4.12028687498898627026D-01,
     *  5.64100308726417532853D-01,  4.12028687498898627026D-01,
     *  1.58488915795935746884D-01,  3.07800338725460822287D-02,
     *  2.77806884291277589608D-03,  1.00004441232499868127D-04,
     *  1.05911554771106663578D-06,  1.52247580425351702016D-09 /)

      CONTAINS
C*MODULE RSMSED  *DECK RSM_SCF_SETVAR
C>
C>    @brief   read matrix data for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_SETVAR

        USE ABSMOD, ONLY : NQMT0A

        INTEGER :: L03, L14

        L03 = NQMT0A+1
        L14 = (NQMT0A+1)*(NQMT0A+1)

        ALLOCATE(QMT(L14),VPR(L03),DMT(L03),VCR(L03))

        CALL RSM_DARE(VPR ,L03, 6,0)
        CALL RSM_DARE(DMT ,L03,24,0)
        CALL RSM_DARE(QMT ,L14,41,0)

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_PUTVAR
C>
C>    @brief   save matrix data for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_PUTVAR

        USE ABSMOD, ONLY : NQMT0A
        
        INTEGER :: L03, L14

        L03 = NQMT0A+1
        L14 = (NQMT0A+1)*(NQMT0A+1)
        CALL RSM_DAWR(QMT   ,  L14, 41,0)
        CALL RSM_DAWR(VPR   ,  L03,  6,0)
        CALL RSM_DAWR(DMT   ,  L03, 24,0)

        DEALLOCATE(QMT,VPR,DMT,VCR)

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_SETPAR
C>
C>    @brief   read parameters for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_SETPAR

        CALL RSM_DARE(ICNTRL,   18,621,0)
        CALL RSM_DARE(RCNTRL,    8,624,0)

        IRISM     = ICNTRL(1)
        ICC       = ICNTRL(2)
        IDFT      = ICNTRL(3)
        ITDDFT    = ICNTRL(4)
        IDCORR    = ICNTRL(5)
        IEQ       = ICNTRL(6)
        ITRRSM    = ICNTRL(7)
        IEXP      = ICNTRL(8)
        NSERCH    = ICNTRL(9)
        ITER_RSMTD= ICNTRL(10)
        NPRINT    = ICNTRL(11)
        ISPEC     = ICNTRL(12) 
        IZINC     = ICNTRL(13)
        ISKIP_RSM = ICNTRL(14)
        IRSM_COUNT= ICNTRL(15)
        ITDCONV   = ICNTRL(16)
        ICONCL    = ICNTRL(17)
        IMCSCF    = ICNTRL(18)

        FEXP      = RCNTRL(1)
        ETOT      = RCNTRL(2)
        EINT1     = RCNTRL(3)
        EINT2     = RCNTRL(4)
        EINT3     = RCNTRL(5)
        TDTYP     = RCNTRL(6)
        G1        = RCNTRL(7)
        G3        = RCNTRL(8)

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_PUTPAR
C>
C>    @brief   save parameters for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_PUTPAR

        ICNTRL( 1) = IRISM
        ICNTRL( 2) = ICC
        ICNTRL( 3) = IDFT
        ICNTRL( 4) = ITDDFT
        ICNTRL( 5) = IDCORR
        ICNTRL( 6) = IEQ
        ICNTRL( 7) = ITRRSM
        ICNTRL( 8) = IEXP
        ICNTRL( 9) = NSERCH
        ICNTRL(10) = ITER_RSMTD
        ICNTRL(11) = NPRINT
        ICNTRL(12) = ISPEC
        ICNTRL(13) = IZINC
        ICNTRL(14) = ISKIP_RSM
        ICNTRL(15) = IRSM_COUNT
        ICNTRL(16) = ITDCONV
        ICNTRL(17) = ICONCL
        ICNTRL(18) = IMCSCF

        RCNTRL( 1) = FEXP
        RCNTRL( 2) = ETOT
        RCNTRL( 3) = EINT1 
        RCNTRL( 4) = EINT2
        RCNTRL( 5) = EINT3
        RCNTRL( 6) = TDTYP 
        RCNTRL( 7) = G1
        RCNTRL( 8) = G3

        CALL RSM_DAWR(ICNTRL,   18,621,0)
        CALL RSM_DAWR(RCNTRL,    8,624,0)

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_SETINF1
C>
C>    @brief   read information of molecule for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_SETINF1
C
        CALL RSM_DARE(INFOMAT,9,511,0)
        NAT  = INFOMAT(1)
        ICH  = INFOMAT(2)
        MUL  = INFOMAT(3)
        NUM  = INFOMAT(4)
        NQMT = INFOMAT(5)
        NE   = INFOMAT(6)
        NA   = INFOMAT(7)
        NB   = INFOMAT(8)
        NROOT= INFOMAT(9)

        ALLOCATE(IAN(NAT),IZCORE(NAT),ZAN(NAT),ANAM(NAT))

        CALL RSM_DARE(IAN   ,  NAT,518,0)  ! IAN
        CALL RSM_DARE(IZCORE,  NAT,519,0)  ! IZCORE
        CALL RSM_DARE(ZAN   ,  NAT,520,0)  ! ZAN
        CALL RSM_DARE(ANAM  ,  NAT,522,0)
C
        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_PUTINF1
C>
C>    @brief   save information of molecule for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
C>    @param   I1: IAN
C>             I2: IZCORE
C>             R1: ZAN
C>             R2: ANAM
C>
        SUBROUTINE RSM_SCF_PUTINF1(I1,I2,R1,R2)
C
        INTEGER,          INTENT(IN   ) :: I1(*), I2(*)
        DOUBLE PRECISION, INTENT(IN   ) :: R1(*), R2(*)
C
        INTEGER :: I0

        INFOMAT(1) = NAT
        INFOMAT(2) = ICH
        INFOMAT(3) = MUL
        INFOMAT(4) = NUM
        INFOMAT(5) = NQMT
        INFOMAT(6) = NE
        INFOMAT(7) = NA
        INFOMAT(8) = NB
        INFOMAT(9) = NROOT

        CALL RSM_DAWR(INFOMAT, 9,511,0)
        CALL RSM_DAWR(I1  ,  NAT,518,0)  ! IAN
        CALL RSM_DAWR(I2  ,  NAT,519,0)  ! IZCORE
        CALL RSM_DAWR(R1  ,  NAT,520,0)  ! ZAN
        CALL RSM_DAWR(R2  ,  NAT,522,0)  ! ANAM

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_CLOSEINF1
C>
C>    @brief   deallocate memolies for INF1
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_CLOSEINF1
C
        DEALLOCATE(IAN,IZCORE,ZAN,ANAM)

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_SETINF2
C>
C>    @brief   read information of molecule for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_SETINF2
C
        ALLOCATE(C(3,NAT))
C
        CALL RSM_DARE(C,3*NAT,521,0)  ! C

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_PUTINF2
C>
C>    @brief   save information of molecule for RISM-SCF calculation
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_PUTINF2(R2)
C
        DOUBLE PRECISION, INTENT(IN   ) :: R2(*)
C
        CALL RSM_DAWR(R2  ,3*NAT,521,0)  ! C

        END SUBROUTINE
C*MODULE RSMSED  *DECK RSM_SCF_CLOSEINF2
C>
C>    @brief   deallocate memories for INF2
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_CLOSEINF2
C
        DEALLOCATE(C)

        END SUBROUTINE
C
      END MODULE
C*MODULE RSM_BSMOD
C>
C>    @brief   module for basis set of QM calculations
C>
C>    @author  Daisuke Yokogawa
C>
      MODULE RSM_BSMOD
      IMPLICIT NONE
C
      INTEGER              :: MXANG, IPURED, IPUREF, NSHELL, NPRIM
      LOGICAL              :: NORM

      INTEGER, ALLOCATABLE :: KSTART(:),KATOM(:),KTYPE(:),KNG(:),
     *                        KLOC(:),KMIN(:),KMAX(:)

      DOUBLE PRECISION, ALLOCATABLE :: EX(:),CS(:),CP(:),CD(:),CF(:),
     *                                 CG(:),CH(:),CI(:)

      CONTAINS
C*MODULE RSM_BSMOD  *DECK RSM_SCF_SETBS
C>
C>    @brief   read information about basis set
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_SETBS

        INTEGER :: I0

        CALL RSM_DARE(I0    ,     1,531,0)
        CALL RSM_DARE(NSHELL,     1,532,0)
        CALL RSM_DARE(NPRIM ,     1,533,0)
        IPUREF = MOD(I0,100)
        I0     = I0/100
        IPURED = MOD(I0,100)
        I0     = I0/100
        MXANG  = MOD(I0,100)
        I0     = I0/100
        IF(I0 == 1) THEN
          NORM = .TRUE.
        ELSE
          NORM = .FALSE.
        ENDIF

        ALLOCATE(KSTART(NSHELL),KATOM(NSHELL),KTYPE(NSHELL),KNG(NSHELL),
     *           KLOC(NSHELL),KMIN(NSHELL),KMAX(NSHELL))
        ALLOCATE(EX(NPRIM),CS(NPRIM),CP(NPRIM),CD(NPRIM),CF(NPRIM),
     *           CG(NPRIM),CH(NPRIM),CI(NPRIM))

        CALL RSM_DARE(KSTART,NSHELL,534,0)
        CALL RSM_DARE(KATOM ,NSHELL,535,0)
        CALL RSM_DARE(KTYPE ,NSHELL,536,0)
        CALL RSM_DARE(KNG   ,NSHELL,537,0)
        CALL RSM_DARE(KLOC  ,NSHELL,538,0)
        CALL RSM_DARE(KMIN  ,NSHELL,539,0) 
        CALL RSM_DARE(KMAX  ,NSHELL,540,0)
        CALL RSM_DARE(EX    ,NPRIM ,541,0)
        CALL RSM_DARE(CS    ,NPRIM ,542,0)
        CALL RSM_DARE(CP    ,NPRIM ,543,0)
        CALL RSM_DARE(CD    ,NPRIM ,544,0)
        CALL RSM_DARE(CF    ,NPRIM ,545,0)
        CALL RSM_DARE(CG    ,NPRIM ,546,0)
        CALL RSM_DARE(CH    ,NPRIM ,547,0)
        CALL RSM_DARE(CI    ,NPRIM ,548,0)

        END SUBROUTINE
C*MODULE RSM_BSMOD  *DECK RSM_SCF_PUTBS
C>
C>    @brief   save information about basis set
C>
C>    @author  Daisuke Yokogawa
C>
C>    @param   I1: KSTART
C>             I2: KATOM
C>             I3: KTYPE
C>             I4: KNG
C>             I5: KLOC
C>             I6: KMIN
C>             I7: KMAX
C>             V1: EX
C>             V2: CS
C>             V3: CP
C>             V4: CD
C>             V5: CF
C>             V6: CG
C>             V7: CH
C>             V8: CI
C>
        SUBROUTINE RSM_SCF_PUTBS(I1,I2,I3,I4,I5,I6,I7,V1,V2,V3,V4,V5,V6,
     *                           V7,V8)

        INTEGER,          INTENT(IN   ) :: I1(*),I2(*),I3(*),I4(*),
     *                                     I5(*),I6(*),I7(*)
        DOUBLE PRECISION, INTENT(IN   ) :: V1(*),V2(*),V3(*),V4(*),
     *                                     V5(*),V6(*),V7(*),V8(*)

        INTEGER :: I0, INORM

        IF(NORM) THEN
          INORM = 1
        ELSE
          INORM = 0
        ENDIF

        I0 = 1000000*INORM + 10000*MXANG + 100*IPURED + IPUREF

        CALL RSM_DAWR(I0    ,     1,531,0)
        CALL RSM_DAWR(NSHELL,     1,532,0)
        CALL RSM_DAWR(NPRIM ,     1,533,0)
        CALL RSM_DAWR(I1    ,NSHELL,534,0)
        CALL RSM_DAWR(I2    ,NSHELL,535,0)
        CALL RSM_DAWR(I3    ,NSHELL,536,0)
        CALL RSM_DAWR(I4    ,NSHELL,537,0)
        CALL RSM_DAWR(I5    ,NSHELL,538,0)
        CALL RSM_DAWR(I6    ,NSHELL,539,0) 
        CALL RSM_DAWR(I7    ,NSHELL,540,0)
        CALL RSM_DAWR(V1    ,NPRIM ,541,0)
        CALL RSM_DAWR(V2    ,NPRIM ,542,0)
        CALL RSM_DAWR(V3    ,NPRIM ,543,0)
        CALL RSM_DAWR(V4    ,NPRIM ,544,0)
        CALL RSM_DAWR(V5    ,NPRIM ,545,0)
        CALL RSM_DAWR(V6    ,NPRIM ,546,0)
        CALL RSM_DAWR(V7    ,NPRIM ,547,0)
        CALL RSM_DAWR(V8    ,NPRIM ,548,0)

        END SUBROUTINE
C*MODULE RSM_BSMOD  *DECK RSM_SCF_CLOSEBS
C>
C>    @brief   deallocate memories for basis set
C>
C>    @author  Daisuke Yokogawa
C>
        SUBROUTINE RSM_SCF_CLOSEBS

        DEALLOCATE(KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX)
        DEALLOCATE(EX,CS,CP,CD,CF,CG,CH,CI)

        END SUBROUTINE

      END MODULE
